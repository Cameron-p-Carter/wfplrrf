import { supabase } from "../shared/base-queries";
import { handleDatabaseError } from "../shared/error-handling";
import { processAllocationAutoGeneration } from "../business-logic/auto-generation";
import type { Tables, TablesInsert, TablesUpdate } from "@/types/supabase";

// Project Resource Requirements CRUD operations
export async function getProjectRequirements(projectId: string): Promise<Tables<"project_requirements_detailed">[]> {
  try {
    const { data, error } = await supabase
      .from("project_requirements_detailed")
      .select("*")
      .eq("project_id", projectId)
      .order("start_date");
    
    if (error) throw error;
    return data;
  } catch (error) {
    handleDatabaseError(error, "fetch project requirements");
  }
}

export async function getGroupedProjectRequirements(projectId: string): Promise<any[]> {
  try {
    const { data, error } = await supabase
      .from("project_requirements_detailed")
      .select("*")
      .eq("project_id", projectId)
      .order("start_date");
    
    if (error) throw error;
    if (!data) return [];

    // Group requirements by parent-child relationships
    const parentRequirements = data.filter(req => !req.parent_requirement_id);
    const childRequirements = data.filter(req => req.parent_requirement_id);

    // Create grouped structure
    const groupedRequirements = parentRequirements.map(parent => ({
      ...parent,
      children: childRequirements.filter(child => child.parent_requirement_id === parent.id)
    }));

    // Add orphaned auto-generated requirements (those without valid parents)
    const orphanedChildren = childRequirements.filter(child => 
      !parentRequirements.find(parent => parent.id === child.parent_requirement_id)
    );

    return [...groupedRequirements, ...orphanedChildren.map(child => ({ ...child, children: [] }))];
  } catch (error) {
    handleDatabaseError(error, "fetch grouped project requirements");
  }
}

export async function getProjectRequirementById(id: string): Promise<Tables<"project_resource_requirements">> {
  try {
    const { data, error } = await supabase
      .from("project_resource_requirements")
      .select("*")
      .eq("id", id)
      .single();
    
    if (error) throw error;
    return data;
  } catch (error) {
    handleDatabaseError(error, "fetch project requirement");
  }
}

export async function createProjectRequirement(requirement: TablesInsert<"project_resource_requirements">): Promise<Tables<"project_resource_requirements">> {
  try {
    const { data, error } = await supabase
      .from("project_resource_requirements")
      .insert(requirement)
      .select()
      .single();
    
    if (error) throw error;
    return data;
  } catch (error) {
    handleDatabaseError(error, "create project requirement");
  }
}

async function updateAllocationDatesForRequirement(requirementId: string, requirement: TablesUpdate<"project_resource_requirements">): Promise<void> {
  try {
    console.log("Updating allocation dates for requirement:", requirementId);
    
    // Get the current requirement to know the old dates
    const { data: currentReq, error: reqError } = await supabase
      .from("project_resource_requirements")
      .select("start_date, end_date")
      .eq("id", requirementId)
      .single();
    
    if (reqError) throw reqError;
    
    // Get all allocations linked to this requirement
    const { data: allocations, error: allocError } = await supabase
      .from("project_allocations")
      .select("id, start_date, end_date")
      .eq("requirement_id", requirementId);
    
    if (allocError) throw allocError;
    if (!allocations || allocations.length === 0) {
      console.log("No allocations to update for requirement:", requirementId);
      return;
    }
    
    console.log("Found allocations to update:", allocations.length);
    
    // Calculate the new dates for allocations
    const newStartDate = requirement.start_date || currentReq.start_date;
    const newEndDate = requirement.end_date || currentReq.end_date;
    
    console.log("Updating allocation dates to:", { start: newStartDate, end: newEndDate });
    
    // Update all allocations with the new dates
    for (const allocation of allocations) {
      const { error: updateError } = await supabase
        .from("project_allocations")
        .update({
          start_date: newStartDate,
          end_date: newEndDate
        })
        .eq("id", allocation.id);
      
      if (updateError) {
        console.error("Error updating allocation:", allocation.id, updateError);
      } else {
        console.log("Updated allocation:", allocation.id, "with new dates");
      }
    }
    
    console.log("Allocation date updates complete");
  } catch (error) {
    console.error("Error updating allocation dates:", error);
    // Don't throw here to avoid blocking the main update operation
  }
}

async function regenerateAutoGeneratedRequirements(requirementId: string): Promise<void> {
  try {
    console.log("Regenerating auto-generated requirements for requirement:", requirementId);
    
    // Get all allocations that are linked to this requirement
    const { data: allocations, error } = await supabase
      .from("project_allocations")
      .select("id")
      .eq("requirement_id", requirementId);
    
    if (error) throw error;
    if (!allocations || allocations.length === 0) {
      console.log("No allocations found for requirement:", requirementId);
      return;
    }
    
    console.log("Found allocations:", allocations.map(a => a.id));
    
    // Check what auto-generated requirements exist before deletion
    const { data: existingAutoGen } = await supabase
      .from("project_resource_requirements")
      .select("id, auto_generated_type, parent_requirement_id, source_allocation_id")
      .eq("parent_requirement_id", requirementId)
      .not("auto_generated_type", "is", null);
    
    console.log("Found auto-generated requirements to delete:", existingAutoGen);
    
    // Delete all auto-generated requirements that have this requirement as their parent
    const { error: deleteError, count } = await supabase
      .from("project_resource_requirements")
      .delete({ count: 'exact' })
      .eq("parent_requirement_id", requirementId)
      .not("auto_generated_type", "is", null);
    
    if (deleteError) throw deleteError;
    console.log("Deleted", count, "auto-generated requirements");
    
    // Regenerate auto-generated requirements for each allocation
    for (const allocation of allocations) {
      console.log("Regenerating for allocation:", allocation.id);
      await processAllocationAutoGeneration(allocation.id);
    }
    
    console.log("Regeneration complete for requirement:", requirementId);
  } catch (error) {
    console.error("Error regenerating auto-generated requirements:", error);
    // Don't throw here to avoid blocking the main update operation
  }
}

export async function updateProjectRequirement(id: string, requirement: TablesUpdate<"project_resource_requirements">): Promise<Tables<"project_resource_requirements">> {
  try {
    const { data, error } = await supabase
      .from("project_resource_requirements")
      .update(requirement)
      .eq("id", id)
      .select()
      .single();
    
    if (error) throw error;
    
    // If dates were updated, update allocation dates and regenerate auto-generated requirements
    if (requirement.start_date || requirement.end_date) {
      await updateAllocationDatesForRequirement(id, requirement);
      await regenerateAutoGeneratedRequirements(id);
    }
    
    return data;
  } catch (error) {
    handleDatabaseError(error, "update project requirement");
  }
}

export async function deleteProjectRequirement(id: string): Promise<void> {
  try {
    // First, delete all auto-generated child requirements that have this requirement as their parent
    const { error: childDeleteError } = await supabase
      .from("project_resource_requirements")
      .delete()
      .eq("parent_requirement_id", id)
      .not("auto_generated_type", "is", null);

    if (childDeleteError) {
      console.error("Error deleting child requirements:", childDeleteError);
      throw childDeleteError;
    }

    // Set requirement_id to null for any allocations linked to this requirement
    // This makes them "orphaned" allocations that can be cleaned up later
    const { error: orphanError } = await supabase
      .from("project_allocations")
      .update({ requirement_id: null })
      .eq("requirement_id", id);

    if (orphanError) {
      console.error("Error orphaning allocations:", orphanError);
      throw orphanError;
    }

    // Then delete the parent requirement itself
    const { error } = await supabase
      .from("project_resource_requirements")
      .delete()
      .eq("id", id);
    
    if (error) throw error;
  } catch (error) {
    handleDatabaseError(error, "delete project requirement");
  }
}