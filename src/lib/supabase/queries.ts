import { createClient } from "./client";
import type { Tables, TablesInsert, TablesUpdate } from "@/types/supabase";

const supabase = createClient();

// Role Types
export async function getRoleTypes() {
  const { data, error } = await supabase
    .from("role_types")
    .select("*")
    .order("name");
  
  if (error) throw error;
  return data;
}

// Project Allocations
export async function getProjectAllocations(projectId: string) {
  const { data, error } = await supabase
    .from("project_allocations_detailed")
    .select("*")
    .eq("project_id", projectId)
    .order("start_date");
  
  if (error) throw error;
  return data;
}

export async function getPersonAllocations(personId: string) {
  const { data, error } = await supabase
    .from("project_allocations_detailed")
    .select("*")
    .eq("person_id", personId)
    .order("start_date");
  
  if (error) throw error;
  return data;
}

export async function getAllAllocations() {
  const { data, error } = await supabase
    .from("project_allocations_detailed")
    .select("*")
    .order("start_date");
  
  if (error) throw error;
  return data;
}

export async function createProjectAllocation(allocation: TablesInsert<"project_allocations">) {
  const { data, error } = await supabase
    .from("project_allocations")
    .insert(allocation)
    .select()
    .single();
  
  if (error) throw error;
  
  // Trigger auto-generation for the new allocation
  if (data) {
    await processAllocationAutoGeneration(data.id);
  }
  
  return data;
}

export async function updateProjectAllocation(id: string, allocation: TablesUpdate<"project_allocations">) {
  const { data, error } = await supabase
    .from("project_allocations")
    .update(allocation)
    .eq("id", id)
    .select()
    .single();
  
  if (error) throw error;
  
  // Trigger auto-generation for the updated allocation
  if (data) {
    await processAllocationAutoGeneration(data.id);
  }
  
  return data;
}

export async function deleteProjectAllocation(id: string) {
  // Clean up auto-generated requirements before deleting the allocation
  await cleanupAutoGeneratedRequirements(id);
  
  const { error } = await supabase
    .from("project_allocations")
    .delete()
    .eq("id", id);
  
  if (error) throw error;
}

// Utility functions for calculations
export async function getPersonUtilization(personId: string, startDate: string, endDate: string) {
  const { data, error } = await supabase
    .from("project_allocations")
    .select("allocation_percentage, start_date, end_date")
    .eq("person_id", personId)
    .gte("end_date", startDate)
    .lte("start_date", endDate);
  
  if (error) throw error;
  
  // Calculate overlapping utilization
  let totalUtilization = 0;
  if (data) {
    for (const allocation of data) {
      const allocStart = new Date(allocation.start_date);
      const allocEnd = new Date(allocation.end_date);
      const queryStart = new Date(startDate);
      const queryEnd = new Date(endDate);
      
      // Check if there's overlap
      if (allocStart <= queryEnd && allocEnd >= queryStart) {
        totalUtilization += allocation.allocation_percentage;
      }
    }
  }
  
  return Math.min(totalUtilization, 100); // Cap at 100%
}

export async function getProjectGaps(projectId: string) {
  // Get requirements
  const requirements = await getProjectRequirements(projectId);
  
  // Get allocations
  const allocations = await getProjectAllocations(projectId);
  
  // Calculate gaps
  const gaps = [];
  
  for (const requirement of requirements) {
    if (!requirement.start_date || !requirement.end_date || !requirement.role_type_id) continue;
    
    // Find allocations that are directly linked to this requirement
    const directAllocations = allocations.filter(allocation => 
      allocation.requirement_id === requirement.id
    );
    
    // Also find legacy allocations (without requirement_id) that overlap with this requirement
    // This ensures backward compatibility with existing data
    const legacyAllocations = allocations.filter(allocation => 
      !allocation.requirement_id && // No requirement_id set (legacy allocation)
      allocation.role_type_id === requirement.role_type_id &&
      allocation.start_date && allocation.end_date &&
      new Date(allocation.start_date) <= new Date(requirement.end_date) &&
      new Date(allocation.end_date) >= new Date(requirement.start_date)
    );
    
    // Combine direct and legacy allocations
    const matchingAllocations = [...directAllocations, ...legacyAllocations];
    
    // Calculate allocated count (sum of allocation percentages / 100)
    const allocatedCount = matchingAllocations.reduce((sum, allocation) => 
      sum + (allocation.allocation_percentage || 0) / 100, 0
    );
    
    const gap = (requirement.required_count || 0) - allocatedCount;
    
    if (gap > 0) {
      gaps.push({
        requirement_id: requirement.id,
        role_type_id: requirement.role_type_id,
        role_type_name: requirement.role_type_name,
        required_count: requirement.required_count,
        allocated_count: allocatedCount,
        gap_count: gap,
        start_date: requirement.start_date,
        end_date: requirement.end_date,
      });
    }
  }
  
  return gaps;
}

export async function getOverAllocatedPeople() {
  const { data: allocations, error } = await supabase
    .from("project_allocations_detailed")
    .select("*");
  
  if (error) throw error;
  
  const overAllocated = [];
  const peopleMap = new Map();
  
  // Group allocations by person and date ranges
  for (const allocation of allocations) {
    if (!allocation.person_id || !allocation.start_date || !allocation.end_date) continue;
    
    const personId = allocation.person_id;
    if (!peopleMap.has(personId)) {
      peopleMap.set(personId, {
        person_id: personId,
        person_name: allocation.person_name,
        allocations: []
      });
    }
    
    peopleMap.get(personId).allocations.push(allocation);
  }
  
  // Check for over-allocation
  for (const [personId, personData] of peopleMap) {
    const allocations = personData.allocations;
    
    // Find overlapping periods
    for (let i = 0; i < allocations.length; i++) {
      for (let j = i + 1; j < allocations.length; j++) {
        const alloc1 = allocations[i];
        const alloc2 = allocations[j];
        
        // Check if periods overlap
        if (new Date(alloc1.start_date!) <= new Date(alloc2.end_date!) &&
            new Date(alloc1.end_date!) >= new Date(alloc2.start_date!)) {
          
          const totalAllocation = (alloc1.allocation_percentage || 0) + (alloc2.allocation_percentage || 0);
          
          if (totalAllocation > 100) {
            overAllocated.push({
              person_id: personId,
              person_name: personData.person_name,
              total_allocation: totalAllocation,
              conflicting_allocations: [alloc1, alloc2]
            });
          }
        }
      }
    }
  }
  
  return overAllocated;
}

export async function getRoleTypeById(id: string) {
  const { data, error } = await supabase
    .from("role_types")
    .select("*")
    .eq("id", id)
    .single();
  
  if (error) throw error;
  return data;
}

export async function createRoleType(roleType: TablesInsert<"role_types">) {
  const { data, error } = await supabase
    .from("role_types")
    .insert(roleType)
    .select()
    .single();
  
  if (error) throw error;
  return data;
}

export async function updateRoleType(id: string, roleType: TablesUpdate<"role_types">) {
  const { data, error } = await supabase
    .from("role_types")
    .update(roleType)
    .eq("id", id)
    .select()
    .single();
  
  if (error) throw error;
  return data;
}

export async function deleteRoleType(id: string) {
  // Check if role type is in use
  const { data: peopleCount } = await supabase
    .from("people")
    .select("id", { count: "exact" })
    .eq("role_type_id", id);

  const { data: requirementsCount } = await supabase
    .from("project_resource_requirements")
    .select("id", { count: "exact" })
    .eq("role_type_id", id);

  if ((peopleCount?.length || 0) > 0 || (requirementsCount?.length || 0) > 0) {
    throw new Error("Cannot delete role type that is currently in use");
  }

  const { error } = await supabase
    .from("role_types")
    .delete()
    .eq("id", id);
  
  if (error) throw error;
}

// Project Resource Requirements
export async function getProjectRequirements(projectId: string) {
  const { data, error } = await supabase
    .from("project_requirements_detailed")
    .select("*")
    .eq("project_id", projectId)
    .order("start_date");
  
  if (error) throw error;
  return data;
}

export async function getGroupedProjectRequirements(projectId: string) {
  const { data, error } = await supabase
    .from("project_requirements_detailed")
    .select("*")
    .eq("project_id", projectId)
    .order("start_date");
  
  if (error) throw error;
  if (!data) return [];

  // Group requirements by parent-child relationships
  const parentRequirements = data.filter(req => !req.parent_requirement_id);
  const childRequirements = data.filter(req => req.parent_requirement_id);

  // Create grouped structure
  const groupedRequirements = parentRequirements.map(parent => ({
    ...parent,
    children: childRequirements.filter(child => child.parent_requirement_id === parent.id)
  }));

  // Add orphaned auto-generated requirements (those without valid parents)
  const orphanedChildren = childRequirements.filter(child => 
    !parentRequirements.find(parent => parent.id === child.parent_requirement_id)
  );

  return [...groupedRequirements, ...orphanedChildren.map(child => ({ ...child, children: [] }))];
}

export async function getProjectRequirementById(id: string) {
  const { data, error } = await supabase
    .from("project_resource_requirements")
    .select("*")
    .eq("id", id)
    .single();
  
  if (error) throw error;
  return data;
}

export async function createProjectRequirement(requirement: TablesInsert<"project_resource_requirements">) {
  const { data, error } = await supabase
    .from("project_resource_requirements")
    .insert(requirement)
    .select()
    .single();
  
  if (error) throw error;
  return data;
}

export async function updateProjectRequirement(id: string, requirement: TablesUpdate<"project_resource_requirements">) {
  const { data, error } = await supabase
    .from("project_resource_requirements")
    .update(requirement)
    .eq("id", id)
    .select()
    .single();
  
  if (error) throw error;
  return data;
}

export async function deleteProjectRequirement(id: string) {
  // First, delete all auto-generated child requirements that have this requirement as their parent
  const { error: childDeleteError } = await supabase
    .from("project_resource_requirements")
    .delete()
    .eq("parent_requirement_id", id)
    .not("auto_generated_type", "is", null);

  if (childDeleteError) {
    console.error("Error deleting child requirements:", childDeleteError);
    throw childDeleteError;
  }

  // Set requirement_id to null for any allocations linked to this requirement
  // This makes them "orphaned" allocations that can be cleaned up later
  const { error: orphanError } = await supabase
    .from("project_allocations")
    .update({ requirement_id: null })
    .eq("requirement_id", id);

  if (orphanError) {
    console.error("Error orphaning allocations:", orphanError);
    throw orphanError;
  }

  // Then delete the parent requirement itself
  const { error } = await supabase
    .from("project_resource_requirements")
    .delete()
    .eq("id", id);
  
  if (error) throw error;
}

// Leave Periods
export async function getPersonLeave(personId: string) {
  const { data, error } = await supabase
    .from("leave_periods")
    .select("*")
    .eq("person_id", personId)
    .order("start_date");
  
  if (error) throw error;
  return data;
}

export async function getAllLeave() {
  const { data, error } = await supabase
    .from("leave_periods")
    .select(`
      *,
      people!inner(
        id,
        name,
        role_types(name)
      )
    `)
    .order("start_date");
  
  if (error) throw error;
  return data;
}

export async function getLeavePeriodById(id: string) {
  const { data, error } = await supabase
    .from("leave_periods")
    .select("*")
    .eq("id", id)
    .single();
  
  if (error) throw error;
  return data;
}

export async function createLeavePeriod(leave: TablesInsert<"leave_periods">) {
  const { data, error } = await supabase
    .from("leave_periods")
    .insert(leave)
    .select()
    .single();
  
  if (error) throw error;
  
  // If the leave is approved, trigger auto-generation for existing allocations
  if (data && leave.status === "approved") {
    await processLeaveCreationForExistingAllocations(leave.person_id, data.id);
  }
  
  return data;
}

export async function updateLeavePeriod(id: string, leave: TablesUpdate<"leave_periods">) {
  const { data, error } = await supabase
    .from("leave_periods")
    .update(leave)
    .eq("id", id)
    .select()
    .single();
  
  if (error) throw error;
  return data;
}

export async function updateLeaveStatus(id: string, status: "pending" | "approved" | "unapproved") {
  // Get the leave period to find the person_id
  const { data: leavePeriod, error: leaveError } = await supabase
    .from("leave_periods")
    .select("person_id")
    .eq("id", id)
    .single();

  if (leaveError) throw leaveError;

  const { data, error } = await supabase
    .from("leave_periods")
    .update({ status })
    .eq("id", id)
    .select()
    .single();
  
  if (error) throw error;
  
  // Process auto-generation based on leave status change
  if (data && leavePeriod) {
    await processLeaveStatusChange(leavePeriod.person_id, id, status);
  }
  
  return data;
}

export async function deleteLeavePeriod(id: string) {
  // Get the leave period details before deletion
  const { data: leave, error: leaveError } = await supabase
    .from("leave_periods")
    .select("*")
    .eq("id", id)
    .single();

  if (leaveError) throw leaveError;
  if (!leave) throw new Error("Leave period not found");

  // If the leave was approved, clean up any leave coverage requirements
  if (leave.status === "approved") {
    await processLeaveDeletionForExistingAllocations(leave.person_id, leave);
  }

  // Delete the leave period
  const { error } = await supabase
    .from("leave_periods")
    .delete()
    .eq("id", id);
  
  if (error) throw error;
}

export async function getPendingLeave() {
  const { data, error } = await supabase
    .from("leave_periods")
    .select(`
      *,
      people!inner(
        id,
        name,
        role_types(name)
      )
    `)
    .eq("status", "pending")
    .order("start_date");
  
  if (error) throw error;
  return data;
}

// Check for leave conflicts during allocation
export async function getPersonLeaveConflicts(personId: string, startDate: string, endDate: string) {
  const { data, error } = await supabase
    .from("leave_periods")
    .select("*")
    .eq("person_id", personId)
    .gte("end_date", startDate)
    .lte("start_date", endDate);
  
  if (error) throw error;
  
  // Separate by leave status
  const conflicts = {
    pending: data?.filter(leave => leave.status === "pending") || [],
    approved: data?.filter(leave => leave.status === "approved") || [],
    unapproved: data?.filter(leave => leave.status === "unapproved") || []
  };
  
  return conflicts;
}

// Auto-generation functions for requirements
export async function generateLeaveGapRequirements(allocationId: string) {
  try {
    // Get the allocation details with simpler query
    const { data: allocation, error: allocError } = await supabase
      .from("project_allocations")
      .select("*")
      .eq("id", allocationId)
      .single();

    if (allocError) {
      console.error("Error fetching allocation:", allocError);
      throw allocError;
    }
    if (!allocation) {
      console.log("No allocation found for ID:", allocationId);
      return [];
    }

    // Get approved leave periods that overlap with this allocation
    const { data: approvedLeave, error: leaveError } = await supabase
      .from("leave_periods")
      .select("*")
      .eq("person_id", allocation.person_id)
      .eq("status", "approved")
      .gte("end_date", allocation.start_date)
      .lte("start_date", allocation.end_date);

    if (leaveError) {
      console.error("Error fetching leave periods:", leaveError);
      throw leaveError;
    }
    if (!approvedLeave || approvedLeave.length === 0) {
      console.log("No approved leave found for person:", allocation.person_id);
      return [];
    }

    console.log("Found approved leave periods:", approvedLeave.length);

    // Create leave coverage requirements for each approved leave period
    const newRequirements = [];
    
    for (const leave of approvedLeave) {
      try {
        // Calculate the overlap period between allocation and leave
        const overlapStart = new Date(Math.max(new Date(allocation.start_date).getTime(), new Date(leave.start_date).getTime()));
        const overlapEnd = new Date(Math.min(new Date(allocation.end_date).getTime(), new Date(leave.end_date).getTime()));
        
        if (overlapStart <= overlapEnd) {
          // Calculate the coverage needed (based on allocation percentage)
          const coverageNeeded = allocation.allocation_percentage / 100;
          
          const requirementData = {
            project_id: allocation.project_id,
            role_type_id: allocation.role_type_id,
            start_date: overlapStart.toISOString().split('T')[0],
            end_date: overlapEnd.toISOString().split('T')[0],
            required_count: coverageNeeded,
            auto_generated_type: 'leave_coverage' as const,
            source_allocation_id: allocation.id,
            parent_requirement_id: allocation.requirement_id
          };

          console.log("Creating leave coverage requirement:", requirementData);

          const { data: newReq, error: createError } = await supabase
            .from("project_resource_requirements")
            .insert(requirementData)
            .select()
            .single();

          if (createError) {
            console.error("Error creating leave coverage requirement:", createError);
            throw createError;
          }
          newRequirements.push(newReq);
        }
      } catch (leaveProcessError) {
        console.error("Error processing leave period:", leave.id, leaveProcessError);
        // Continue with other leave periods instead of failing completely
      }
    }

    console.log("Created leave coverage requirements:", newRequirements.length);
    return newRequirements;
  } catch (error) {
    console.error("Error in generateLeaveGapRequirements:", error);
    return []; // Return empty array instead of throwing to prevent blocking allocation creation
  }
}

export async function generatePartialAllocationGaps(allocationId: string) {
  try {
    // Get the allocation details with simpler query
    const { data: allocation, error: allocError } = await supabase
      .from("project_allocations")
      .select("*")
      .eq("id", allocationId)
      .single();

    if (allocError) {
      console.error("Error fetching allocation for partial gap:", allocError);
      throw allocError;
    }
    if (!allocation || !allocation.requirement_id) {
      console.log("No allocation or requirement_id found for partial gap:", allocationId);
      return [];
    }

    // Get the parent requirement
    const { data: requirement, error: reqError } = await supabase
      .from("project_resource_requirements")
      .select("*")
      .eq("id", allocation.requirement_id)
      .single();

    if (reqError) {
      console.error("Error fetching parent requirement:", reqError);
      throw reqError;
    }
    if (!requirement || requirement.auto_generated_type) {
      console.log("Parent requirement is auto-generated, skipping partial gap creation");
      return []; // Don't create gaps for auto-generated requirements
    }

    // Check if this allocation is less than 100%
    if (allocation.allocation_percentage >= 100) {
      console.log("Allocation is 100%, no partial gap needed");
      return [];
    }

    // Calculate the gap - this should be the remaining amount needed to fulfill the requirement
    const gapPercentage = 100 - allocation.allocation_percentage;
    const gapAmount = gapPercentage / 100;

    console.log("Creating partial gap for", gapPercentage, "% (", gapAmount, "person) for allocation:", allocation.id);
    console.log("Allocation details:", {
      person_id: allocation.person_id,
      project_id: allocation.project_id,
      requirement_id: allocation.requirement_id,
      allocation_percentage: allocation.allocation_percentage
    });

    // Check if a partial gap requirement already exists for this allocation
    const { data: existingGap } = await supabase
      .from("project_resource_requirements")
      .select("*")
      .eq("auto_generated_type", "partial_gap")
      .eq("source_allocation_id", allocation.id);

    if (existingGap && existingGap.length > 0) {
      console.log("Partial gap already exists");
      return existingGap; // Gap already exists
    }

    // Create the partial gap requirement
    const requirementData = {
      project_id: allocation.project_id,
      role_type_id: allocation.role_type_id,
      start_date: allocation.start_date,
      end_date: allocation.end_date,
      required_count: gapAmount,
      auto_generated_type: 'partial_gap' as const,
      source_allocation_id: allocation.id,
      parent_requirement_id: allocation.requirement_id
    };

    console.log("Creating partial gap requirement:", requirementData);

    const { data: newReq, error: createError } = await supabase
      .from("project_resource_requirements")
      .insert(requirementData)
      .select()
      .single();

    if (createError) {
      console.error("Error creating partial gap requirement:", createError);
      throw createError;
    }
    
    console.log("Created partial gap requirement:", newReq.id);
    return [newReq];
  } catch (error) {
    console.error("Error in generatePartialAllocationGaps:", error);
    return []; // Return empty array instead of throwing to prevent blocking allocation creation
  }
}

export async function cleanupAutoGeneratedRequirements(allocationId: string) {
  // Get all auto-generated requirements linked to this allocation
  const { data: autoGenerated, error } = await supabase
    .from("project_resource_requirements")
    .select("*")
    .eq("source_allocation_id", allocationId)
    .not("auto_generated_type", "is", null);

  if (error) throw error;
  if (!autoGenerated || autoGenerated.length === 0) return;

  // For each auto-generated requirement, check if it has any allocations
  for (const req of autoGenerated) {
    const { data: allocations } = await supabase
      .from("project_allocations")
      .select("id")
      .eq("requirement_id", req.id);

    if (!allocations || allocations.length === 0) {
      // No allocations, safe to delete
      await supabase
        .from("project_resource_requirements")
        .delete()
        .eq("id", req.id);
    }
    // If there are allocations, keep the requirement but it becomes an "over-allocation"
  }
}

export async function processAllocationAutoGeneration(allocationId: string) {
  try {
    // Clean up any existing auto-generated requirements for this allocation
    await cleanupAutoGeneratedRequirements(allocationId);
    
    // Generate new requirements
    const leaveGaps = await generateLeaveGapRequirements(allocationId);
    const partialGaps = await generatePartialAllocationGaps(allocationId);
    
    return {
      leaveGaps,
      partialGaps,
      success: true
    };
  } catch (error) {
    console.error("Error in auto-generation:", error);
    return {
      leaveGaps: [],
      partialGaps: [],
      success: false,
      error
    };
  }
}

export async function processLeaveCreationForExistingAllocations(personId: string, leaveId: string) {
  try {
    // Get the newly created leave period
    const { data: leave } = await supabase
      .from("leave_periods")
      .select("*")
      .eq("id", leaveId)
      .single();

    if (!leave) return { success: false, error: "Leave period not found" };

    // Find all allocations for this person that overlap with the new leave period
    const { data: allocations } = await supabase
      .from("project_allocations")
      .select("*")
      .eq("person_id", personId)
      .gte("end_date", leave.start_date)
      .lte("start_date", leave.end_date);

    if (allocations && allocations.length > 0) {
      console.log(`Found ${allocations.length} allocations that overlap with new leave period`);
      
      // Regenerate leave gap requirements for all affected allocations
      for (const allocation of allocations) {
        console.log(`Processing allocation ${allocation.id} for new leave coverage`);
        await generateLeaveGapRequirements(allocation.id);
      }
    }

    return { success: true };
  } catch (error) {
    console.error("Error processing leave creation for existing allocations:", error);
    return { success: false, error };
  }
}

export async function processLeaveDeletionForExistingAllocations(personId: string, deletedLeave: Tables<"leave_periods">) {
  try {
    console.log(`Processing leave deletion for person ${personId}, leave period: ${deletedLeave.start_date} to ${deletedLeave.end_date}`);

    // Find all allocations for this person that overlap with the deleted leave period
    const { data: allocations } = await supabase
      .from("project_allocations")
      .select("*")
      .eq("person_id", personId)
      .gte("end_date", deletedLeave.start_date)
      .lte("start_date", deletedLeave.end_date);

    if (allocations && allocations.length > 0) {
      console.log(`Found ${allocations.length} allocations that overlapped with deleted leave period`);
      
      // For each affected allocation, clean up leave coverage requirements that match the deleted leave period
      for (const allocation of allocations) {
        console.log(`Cleaning up leave coverage requirements for allocation ${allocation.id}`);
        
        // Find leave coverage requirements for this allocation
        const { data: leaveReqs } = await supabase
          .from("project_resource_requirements")
          .select("*")
          .eq("auto_generated_type", "leave_coverage")
          .eq("source_allocation_id", allocation.id);

        if (leaveReqs && leaveReqs.length > 0) {
          for (const req of leaveReqs) {
            // Check if this requirement overlaps with the deleted leave period
            const reqStart = new Date(req.start_date);
            const reqEnd = new Date(req.end_date);
            const leaveStart = new Date(deletedLeave.start_date);
            const leaveEnd = new Date(deletedLeave.end_date);

            // If the requirement overlaps with the deleted leave period
            if (reqStart <= leaveEnd && reqEnd >= leaveStart) {
              console.log(`Found overlapping leave coverage requirement ${req.id}, checking if it can be deleted`);
              
              // Check if this requirement has any allocations
              const { data: reqAllocations } = await supabase
                .from("project_allocations")
                .select("id")
                .eq("requirement_id", req.id);

              if (!reqAllocations || reqAllocations.length === 0) {
                // Safe to delete - no one is allocated to this leave coverage requirement
                console.log(`Deleting leave coverage requirement ${req.id} (no allocations)`);
                await supabase
                  .from("project_resource_requirements")
                  .delete()
                  .eq("id", req.id);
              } else {
                console.log(`Keeping leave coverage requirement ${req.id} (has ${reqAllocations.length} allocations)`);
              }
            }
          }
        }
      }
    }

    return { success: true };
  } catch (error) {
    console.error("Error processing leave deletion for existing allocations:", error);
    return { success: false, error };
  }
}

export async function processLeaveStatusChange(personId: string, leaveId: string, newStatus: "pending" | "approved" | "unapproved") {
  try {
    if (newStatus === "approved") {
      // Get all allocations for this person that might be affected by this leave
      const { data: leave } = await supabase
        .from("leave_periods")
        .select("*")
        .eq("id", leaveId)
        .single();

      if (!leave) return { success: false, error: "Leave period not found" };

      const { data: allocations } = await supabase
        .from("project_allocations")
        .select("*")
        .eq("person_id", personId)
        .gte("end_date", leave.start_date)
        .lte("start_date", leave.end_date);

      if (allocations) {
        // Regenerate leave gap requirements for all affected allocations
        for (const allocation of allocations) {
          await generateLeaveGapRequirements(allocation.id);
        }
      }
    } else if (newStatus === "unapproved") {
      // Remove any leave coverage requirements that were created for this leave
      const { data: leave } = await supabase
        .from("leave_periods")
        .select("*")
        .eq("id", leaveId)
        .single();

      if (!leave) return { success: false, error: "Leave period not found" };

      // Find allocations that overlap with this leave period
      const { data: allocations } = await supabase
        .from("project_allocations")
        .select("*")
        .eq("person_id", personId)
        .gte("end_date", leave.start_date)
        .lte("start_date", leave.end_date);

      if (allocations) {
        for (const allocation of allocations) {
          // Find and clean up leave coverage requirements for this allocation
          const { data: leaveReqs } = await supabase
            .from("project_resource_requirements")
            .select("*")
            .eq("auto_generated_type", "leave_coverage")
            .eq("source_allocation_id", allocation.id);

          if (leaveReqs) {
            for (const req of leaveReqs) {
              // Check if this requirement overlaps with the denied leave
              const reqStart = new Date(req.start_date);
              const reqEnd = new Date(req.end_date);
              const leaveStart = new Date(leave.start_date);
              const leaveEnd = new Date(leave.end_date);

              if (reqStart <= leaveEnd && reqEnd >= leaveStart) {
                // Check if it has allocations
                const { data: reqAllocations } = await supabase
                  .from("project_allocations")
                  .select("id")
                  .eq("requirement_id", req.id);

                if (!reqAllocations || reqAllocations.length === 0) {
                  // Safe to delete
                  await supabase
                    .from("project_resource_requirements")
                    .delete()
                    .eq("id", req.id);
                }
              }
            }
          }
        }
      }
    }

    return { success: true };
  } catch (error) {
    console.error("Error processing leave status change:", error);
    return { success: false, error };
  }
}

// People
export async function getPeople() {
  const { data, error } = await supabase
    .from("people_with_roles")
    .select("*")
    .order("name");
  
  if (error) throw error;
  return data;
}

export async function getPersonById(id: string) {
  const { data, error } = await supabase
    .from("people")
    .select("*")
    .eq("id", id)
    .single();
  
  if (error) throw error;
  return data;
}

export async function createPerson(person: TablesInsert<"people">) {
  const { data, error } = await supabase
    .from("people")
    .insert(person)
    .select()
    .single();
  
  if (error) throw error;
  return data;
}

export async function updatePerson(id: string, person: TablesUpdate<"people">) {
  const { data, error } = await supabase
    .from("people")
    .update(person)
    .eq("id", id)
    .select()
    .single();
  
  if (error) throw error;
  return data;
}

export async function deletePerson(id: string) {
  // Check if person has active allocations
  const { data: allocations } = await supabase
    .from("project_allocations")
    .select("id", { count: "exact" })
    .eq("person_id", id);

  if ((allocations?.length || 0) > 0) {
    throw new Error("Cannot delete person with active project allocations");
  }

  const { error } = await supabase
    .from("people")
    .delete()
    .eq("id", id);
  
  if (error) throw error;
}

// Projects
export async function getProjects() {
  const { data, error } = await supabase
    .from("projects")
    .select("*")
    .order("name");
  
  if (error) throw error;
  return data;
}

export async function getProjectById(id: string) {
  const { data, error } = await supabase
    .from("projects")
    .select("*")
    .eq("id", id)
    .single();
  
  if (error) throw error;
  return data;
}

export async function createProject(project: TablesInsert<"projects">) {
  const { data, error } = await supabase
    .from("projects")
    .insert(project)
    .select()
    .single();
  
  if (error) throw error;
  return data;
}

export async function updateProject(id: string, project: TablesUpdate<"projects">) {
  const { data, error } = await supabase
    .from("projects")
    .update(project)
    .eq("id", id)
    .select()
    .single();
  
  if (error) throw error;
  return data;
}

export async function deleteProject(id: string) {
  // Check if project has active allocations or requirements
  const { data: allocations } = await supabase
    .from("project_allocations")
    .select("id", { count: "exact" })
    .eq("project_id", id);

  const { data: requirements } = await supabase
    .from("project_resource_requirements")
    .select("id", { count: "exact" })
    .eq("project_id", id);

  if ((allocations?.length || 0) > 0 || (requirements?.length || 0) > 0) {
    throw new Error("Cannot delete project with active allocations or resource requirements");
  }

  const { error } = await supabase
    .from("projects")
    .delete()
    .eq("id", id);
  
  if (error) throw error;
}
